<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>

// setting up constants
        
const PLAYER_BLUE = 1;
const PLAYER_RED = 2;
        
const UNIT_SOLDIER = 1;
const UNIT_BASE = 2;
const UNIT_TURRET = 3;
const UNIT_BARRACKS = 4;
const UNIT_WALL = 5;
const UNIT_CANNON = 6;

const SHOT_BASIC = 1;
const SHOT_EXPLOSIVE = 2;
    
// game object properties (some things still hard coded)
// jump
// spawm
// shoot
        
        
var unit_properties = new Map();
unit_properties.set(UNIT_SOLDIER, 
                    {
    building: false, sprite: 'soldier', health: 5,
    movement: {minspeed: 0, maxspeed: 80},
    jump: {prob: 0.1, velocity: 300},
    shoot: {type: SHOT_BASIC, ticks: 10, velocity: 250, amin: 20, amax: 20}
                    });
        
unit_properties.set(UNIT_BASE, 
                    {
    building: true, width: 80, sprite: 'base', health: 200,
    spawn: {type: UNIT_SOLDIER, ticks: 40}
                    });
        
unit_properties.set(UNIT_TURRET, 
                    {
    building: true, width: 40, sprite: 'turret', health: 40,
    shoot: {type: SHOT_BASIC, ticks: 10, amin: 10, amax: 50}
                    });
        
unit_properties.set(UNIT_BARRACKS, 
                    {
    building: true, width: 40, sprite: 'barracks', health: 40,
    spawn: {type: UNIT_SOLDIER, ticks: 100}
                    });
        
unit_properties.set(UNIT_WALL, 
                    {
    building: true, width: 40, sprite: 'wall', health: 100,
                    });
        
unit_properties.set(UNIT_CANNON, 
                    {
    building: false, sprite: 'cannon', health: 20,
    movement: {minspeed: 20, maxspeed: 20},
    shoot: {type: SHOT_EXPLOSIVE, ticks: 20, velocity: 300, amin: 40, amax: 50}
                    });
    
var shot_properties = new Map();
shot_properties.set(SHOT_BASIC, {sprite: 'shot', damage: 3, explosion: null});
shot_properties.set(SHOT_EXPLOSIVE, {sprite: 'big_shot', damage: 5, explosion: {type: SHOT_BASIC, amount: 5}});
        
// timing system
        
const tick_millis = 100;
var last_tick = 0;
var tick_number = 0;

        
// game config
    
var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    parent: 'phaser-example',
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var game = new Phaser.Game(config);
        

var blue_units;
var blue_shots;
var red_units;
var red_shots;
        
var dummy = 0;
        
var money = 100;
var money_text;
var help_text;
    
var ui_options = [5, 4, 3]; // UI order
var ui_selection_image = null; // sprite for current selection
var ui_selection_unit = -1;
        
// TODO: ADD VALUES FOR DIFFERENT UNITS

function preload ()
{
    // basic
    this.load.image('bg_image', 'bg_image.png');
    this.load.image('tile', 'tile.png');
    
    // UI
    this.load.image('ui_holder', 'ui_holder.png');
    this.load.image('selection', 'selection.png');
    
    // units
    this.load.image('blue_soldier', 'blue_soldier.png');
    this.load.image('blue_cannon', 'blue_cannon.png');
    this.load.image('red_soldier', 'red_soldier.png');
    this.load.image('red_cannon', 'red_cannon.png');
    
    // buildings
    this.load.image('blue_base', 'blue_base.png');
    this.load.image('red_base', 'red_base.png');
    this.load.image('blue_turret', 'blue_turret.png');
    this.load.image('blue_barracks', 'blue_barracks.png');
    this.load.image('blue_wall', 'blue_wall.png');
    
    // shots
    this.load.image('shot', 'shot.png');
    this.load.image('big_shot', 'big_shot.png');
}

function create ()
{

    // add bg image
    this.add.image(400, 300, 'bg_image');
    
    // UI
    this.add.image(400, 600-20, 'ui_holder');
    
    // TODO: Make this better
    this.add.image(120+20, 600-20, 'blue_wall').setScale(0.5);
    this.add.image(160+20, 600-20, 'blue_barracks').setScale(0.5);
    this.add.image(200+20, 600-20, 'blue_turret').setScale(0.5);

    platforms = this.physics.add.staticGroup();
    // ground
    for (var i = 0; i < 20; i++) platforms.create(i*40 + 20, 600-20-40, 'tile');
    //for (var i = 0; i < 4; i++) platforms.create(i*40 + 20, 600-20-160, 'tile');
    //for (var i = 0; i < 4; i++) platforms.create(i*40 + 20, 600-20-400, 'tile');
    //for (var i = 0; i < 5; i++) platforms.create((i+9)*40 + 20, 600-20-80, 'tile');
    //for (var i = 0; i < 2; i++) platforms.create((i+11)*40 + 20, 600-20-120, 'tile');
    
    //for (var i = 0; i < 5; i++) platforms.create((i+3)*40 + 20, 600-20-240, 'tile');
    //for (var i = 0; i < 5; i++) platforms.create((i+15)*40 + 20, 600-20-240, 'tile');
    //for (var i = 0; i < 5; i++) platforms.create((i+15)*40 + 20, 600-20-440, 'tile');
    //platforms.create(7*40 + 20, 600-20-160, 'tile');
    //platforms.create(7*40 + 20, 600-20-200, 'tile');
    
    // unit physics groups
    blue_units = this.physics.add.group();
    blue_shots = this.physics.add.group();
    red_units = this.physics.add.group();
    red_shots = this.physics.add.group();
    
    
    this.physics.add.collider(blue_units, platforms);
    this.physics.add.collider(red_units, platforms);
    this.physics.add.collider(red_units, blue_units);
    
    this.physics.add.overlap(blue_units, red_shots, unit_hit, null, this);
    this.physics.add.overlap(red_units, blue_shots, unit_hit, null, this);
    this.physics.add.overlap(blue_shots, platforms, shot_hit_ground, null, this);
    this.physics.add.overlap(red_shots, platforms, shot_hit_ground, null, this);
    
    // GUI
    money_text = this.add.text(5, 600-25, 'Gold: ' + money, { fontFamily: 'Courier' }).setColor('#FFFFFF');
    money_text.setDepth(1);
    help_text = this.add.text(400, 600-25, 'Nothing selected', { fontFamily: 'Courier' }).setColor('#FFFFFF');
    help_text.setDepth(1);
    
    // TODO: Add tile based coordinates
    
    // create the blue and red base
    create_unit(2, 80, 600-120, 1, this);
    create_unit(2, 800 - 80, 600-120, 2, this);
    
    // create some test stuff
    
    // barracks
    //create_unit(4, 120+20, 600-100, 1, this);
    //create_unit(4, 120+60, 600-100, 1, this);
    //create_unit(4, 120+100, 600-100, 1, this);
    
    // turrets
    //create_unit(3, 120+100, 600-300, 1, this);
    //create_unit(3, 120+140, 600-300, 1, this);
    //create_unit(3, 120+140, 600-100, 1, this);
    
    // wall
    //create_unit(5, 120+180, 600-100, 1, this);
    
    // tank
    create_unit(6, 100, 600 - 100 , 1, this);
    create_unit(6, 120, 600 - 100 , 1, this);
    
    create_unit(6, 700, 600-100 , 2, this);
    
}

function update ()
{
    
    // UI logic
    
    // TODO: This is garbage
    if (game.input.mousePointer.isDown) {
        //console.log(ui_selection_image);
        var do_select = -1;
        var do_select_index = -1;
        if (game.input.mousePointer.y >= 600 - 40) {
            var index = Math.floor((game.input.mousePointer.x - 120) / 40)
            if (index >= 0 && index <= ui_options.length - 1) {
                do_select = ui_options[index];
                do_select_index = index;
            }
        }
        if (do_select == -1 && ui_selection_unit != -1) {
            if (ui_selection_image != null) {
                ui_selection_image.destroy();
            }
            ui_selection_unit = -1;
        } else if (do_select >= 0 && do_select != this.ui_selection_unit) {
            if (ui_selection_image != null) {
                ui_selection_image.destroy();
            }
            ui_selection_unit = do_select;
            ui_selection_image = this.add.image(120+20 + 40*do_select_index, 600-20, 'selection');
        }    
    }
    
    
    // Game logic
    cur_time = this.time.now;
    // Run a game tick
    if (cur_time - last_tick > tick_millis) {
        last_tick = cur_time;
        // TODO: Is time needed here
        blue_units.children.each(function(unit) { run_unit_ai(unit, tick_number, this) }, this);
        red_units.children.each(function(unit) { run_unit_ai(unit, tick_number, this) }, this);    
        tick_number += 1;
    }
    
    // kill shots over the border
    // TODO: Have a faster implementation for this
    blue_shots.children.each(function(shot) { check_shot_outside(shot) }, this);
    red_shots.children.each(function(shot) { check_shot_outside(shot) }, this);
    
}

function create_unit(type, xpos, ypos, player, th)
{
    var graph_name;
    var group;
    if (player == PLAYER_BLUE) {
        group = blue_units;
        graph_name = 'blue_';
    } else if (player == PLAYER_RED) {
        group = red_units;
        graph_name = 'red_';
    } else {
        console.error('bad player type');
        return;
    }
    var props = unit_properties.get(type);
    if (props == null) {
        console.error('Unknown unit type');
        return;
    }
    graph_name += props.sprite;
    var health;
    var is_building = false;
    new_unit = group.create(xpos, ypos, graph_name);
    new_unit.x_player = player;
    new_unit.x_type = type;    
    new_unit.x_health = props.health;
    new_unit.x_created = tick_number;
    new_unit.x_props = props;
    if (props.building) {
        new_unit.setImmovable(true);
        new_unit.x_health_bar = th.add.rectangle(xpos, ypos-props.width/2, props.width*0.75, 2, 0x00ff00);
        new_unit.x_health_bar.alpha = 0.25;
        new_unit.x_health_bar.setDepth(1);
    } else {
        new_unit.setGravity(0, 300);
        new_unit.setBounce(0.2);    
    }
}
        
// Fire a shot
function create_shot(type, player, xpos, ypos, xvel, yvel, th) {
    var group;
    if (player == PLAYER_BLUE) {
        group = blue_shots;
    } else if (player == PLAYER_RED) {
        group = red_shots;
    } else {
        console.error('bad player type for shot');
        return;
    }
    var props = shot_properties.get(type);
    if (props == null) {
        console.error('Unknown shot type');
        return;
    }
    new_shot = group.create(xpos, ypos, props.sprite);   
    new_shot.x_player = player;
    new_shot.x_type = type;
    new_shot.x_props = props;
    new_shot.setVelocityX(xvel);
    new_shot.setVelocityY(yvel);
    new_shot.setGravity(0, 300);
}
        
// Run unit logic for a single tick
function run_unit_ai(unit, tick_count, th)
{
    // TODO: HAndle this better?
    if (unit.x_player == 1) {
        if (unit.x > 600-40) unit.destroy();
    } else {
        if (unit.x < 40) unit.destroy();
    }
    dir_to_enemy = unit.x_player == 1 ? 1 : -1;
    var props = unit.x_props;
    
    // handle movement and jumps only every 5 th tick so that it's less random
    if (tick_count % 5 == 0) {
        if (props.movement != null) {
            var velx = Math.random()*(props.movement.maxspeed - props.movement.minspeed) + props.movement.minspeed;
            unit.setVelocityX(dir_to_enemy*velx);
        }
        if (props.jump != null) {
            if (Math.random() < props.jump.prob) {
                unit.setVelocityY(-props.jump.velocity);
            }
        }
    }
    
    // shooting
    if (props.shoot != null) {
        var shoot = props.shoot;
        if (unit.x_last_shot == null) unit.x_last_shot = unit.x_created;
        if (tick_count - unit.x_last_shot > shoot.ticks) {
            var angle = Math.PI * (Math.random()*(shoot.amax - shoot.amin) + shoot.amin) / 180.0;
            var velx = Math.cos(angle)*shoot.velocity;
            var vely = -Math.sin(angle)*shoot.velocity;
            create_shot(shoot.type, unit.x_player, unit.x, unit.y, dir_to_enemy*velx, vely, th);
            unit.x_last_shot = tick_count;
        }
    }

    // spawn logic
    if (props.spawn != null) {
        var spawn = props.spawn;
        if (unit.x_last_spawn == null) unit.x_last_spawn = unit.x_created;
        if (tick_count - unit.x_last_spawn > spawn.ticks) {
            create_unit(spawn.type, unit.x, unit.y, unit.x_player, th);
            unit.x_last_spawn = tick_count;
        }
    }
    
    // Earning logic
    
    
    /*
    // TODO: Implemente proper AI
    if (unit.x_type == 1) { // SOLDIER
        if (cur_time - unit.x_last_update > 500) {
            unit.x_last_update = cur_time;
            unit.setVelocityX(Math.random()*50*dir_to_enemy);
            if (Math.random() > 0.85) {
                unit.setVelocityY(-200);
            } 
            if (Math.random() > 0.5) {
                shoot(1, unit.x_player, unit.x, unit.y, dir_to_enemy*200, -50, th);
            } 
        }
    } else if (unit.x_type == 2) { // BASE
        // create an unit every 5 seconds
        if (cur_time - unit.x_last_update > 5000) {
            unit.x_last_update = cur_time;
            create_unit(1, unit.x, unit.y, unit.x_player, th);
            // Give money every 5 seconds
            update_money(25);
        }
    } else if (unit.x_type == 3) { // TURRET
        // shoot in random directions quickly
        if (cur_time - unit.x_last_update > 300) {
            unit.x_last_update = cur_time;
            a = Math.random()*3.14*0.3;
            velx = Math.cos(a)*400;
            vely = -Math.sin(a)*400;
            shoot(1, unit.x_player, unit.x, unit.y, velx, vely, th);
        }
    } else if (unit.x_type == 4) { // BARRACKS
        // create an unit every 5 seconds
        if (cur_time - unit.x_last_update > 5000) {
            unit.x_last_update = cur_time;
            create_unit(1, unit.x, unit.y, unit.x_player, th);
        }
    } else if (unit.x_type == 6) { // CANNON
        if (cur_time - unit.x_last_update > 2000) {
            unit.x_last_update = cur_time;
            unit.setVelocityX(Math.random()*10*dir_to_enemy);
            shoot(2, unit.x_player, unit.x, unit.y, dir_to_enemy*200, -200, th);
        }
    }
    */
}
        
function unit_hit(unit, shot)
{
    var props = shot.x_props;
    update_unit_health(unit, -props.damage);   
    destroy_shot(shot, this);
}
        
function shot_hit_ground(shot, tile)
{
    destroy_shot(shot, this)
}
        
function destroy_shot(shot, th)
{
    // Big shot explosion
    var props = shot.x_props;
    if (props.explosion != null) {
        var explosion = props.explosion;
        for (i = 0; i < explosion.amount; i++) {
            velx = (Math.random() - 0.5)*200;
            vely = -(Math.random()+ 0.5)*200;
            create_shot(explosion.type, shot.x_player, shot.x, shot.y - 5, velx, vely, th);    
        }
    }
    shot.destroy();
}
        
// Updare unit health and potentially a health bar also
// Kills the unit if health below zero
function update_unit_health(unit, amount)
{
    var props = unit.x_props;
    unit.x_health += amount;
    if (unit.x_health > props.health) {
        unit.x_health = props.health;
    }
    if (props.building) {
        
        var fraction = unit.x_health / props.health;
        var new_width = props.width * 0.75 * fraction;
        if (fraction >= 0.5) {
            unit.x_health_bar.fillColor = '0x00ff00';
        } else if (fraction < 0.5 && fraction >= 0.25) {
            unit.x_health_bar.fillColor = '0xffff00';
        } else {
            unit.x_health_bar.fillColor = '0xff0000';
        }
        unit.x_health_bar.width = new_width;
    }
    if (unit.x_health <= 0) {   
        unit.destroy();
        if (unit.x_health_bar != null) {
            unit.x_health_bar.destroy();
        }
    }
}
        
function check_shot_outside(shot)
{
    if (shot.x < 0 || shot.x > 800 || shot.y < 0 || shot.y > 600) {
        shot.destroy();
    }            
}
        
function update_money(amount)
{
    money += amount;
    if (money < 0) {
        money = 0;
    }
    money_text.setText('Gold: ' + money);
}

    </script>

</body>
</html>